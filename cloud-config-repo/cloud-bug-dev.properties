#service name
server.port=12305
spring.application.name=cloud-bug-service
spring.profiles.default=production

include.properties=lz-common-dev.properties

#mysqldb.datasource.url=jdbc:mysql://10.10.10.236:3306/hr?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8
#mysqldb.datasource.username=root
#mysqldb.datasource.password=root

#------------------------------------------
hikari.jdbcUrl=jdbc:mysql://${dbServer}/${dbSchema}?autoReconnect=true&useUnicode=true&characterEncoding=utf-8&failOverReadOnly=false
hikari.username=${db.user}
hikari.password=${db.password}
hikari.driverClassName=com.mysql.jdbc.Driver
hikari.minIdle=3
hikari.maxPoolSize=15
hikari.maxLifetime=1800000
hikari.connectionTimeout=5000
hikari.idleTimeout=600000
#------------------------------------------

dbServer=${bug.dbServer}
#dbServer=10.10.10.239:3306
dbSchema=bug
c3p0.jdbcUrl=jdbc:mysql://${dbServer}/${dbSchema}?autoReconnect=true&useUnicode=true&characterEncoding=utf-8&failOverReadOnly=false
c3p0.user=root
c3p0.password=crypt[k28Xp5+74kM=]
c3p0.driverClass=com.mysql.jdbc.Driver
# default 3, 15, 3
c3p0.minPoolSize=5
c3p0.maxPoolSize=100
c3p0.initialPoolSize=10
# 1800秒内未使用则连接被丢弃, default 永不丢弃
c3p0.maxIdleTime=1800
# c3p0一次同时获取的连接数 Default: 3
c3p0.acquireIncrement=3
# 失败后重复尝试的次数。Default: 30
c3p0.acquireRetryAttempts=30
# 每60秒检查空闲连接
c3p0.idleConnectionTestPeriod=60
# 两次连接间隔时间，单位毫秒。Default: 1000
c3p0.acquireRetryDelay=1000
# c3p0将建一张名为test的空表
c3p0.automaticTestTable=test
c3p0.preferredTestQuery=select id from test where id=1
c3p0.maxStatements=1000
c3p0.breakAfterAcquireFailure=false
c3p0.testConnectionOnCheckout=false
# true那么在取得连接的同时将校验连接的有效性。Default: false
c3p0.testConnectionOnCheckin=false
# 当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException,如设为0则无限期等待。单位毫秒。Default: 0
c3p0.checkoutTimeout=5000


spring.data.mongodb.uri=mongodb://admin:crypt[criMcmm5ost7o9vCxzap4A==]@10.10.10.237:10000/hr2

spring.redis.cluster.nodes=${redis.nodes}
spring.redis.cluster.host=${redis.host}
spring.redis.cluster.port=${redis.port}
spring.redis.cluster.passwd=${redis.passwd}
spring.redis.cluster.timeOut=${redis.timeOut}
spring.redis.cluster.max-redirects=${redis.max-redirects}

#service discovery url
#eureka.server.port=8761
#eureka.instance.hostname=10.10.10.236
#eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${eureka.server.port}/eureka/
#
#eureka.client.healthcheck.enabled=true
#eureka.instance.lease-renewal-interval-in-seconds=10
#eureka.instance.lease-expiration-duration-in-seconds=30
#eureka.instance.prefer-ip-address=true
#eureka.instance.instance-id=${spring.cloud.client.ipAddress}:${spring.application.name}:${server.port}
#
#temp.path.win=d:/temp/bug
#temp.path.linux=/home/wtb/temp/bug
#
#spring.rabbitmq.host=10.10.10.201
#spring.rabbitmq.port=5672
#spring.rabbitmq.username=guest
#spring.rabbitmq.password=guest
#spring.rabbitmq.virtualHost=/
#
#mail.sendAddr=lz.admin@icerno.com
#mail.smtpHost=smtp.qiye.163.com
#mail.userName=lz.admin@icerno.com
#mail.password=lz.Admin!
#
##检查用户权限,0=不检查登录，1=不检查权限，2=检查权限
#auth.check=1

#service discovery url
eureka.server.port=${eureka.port}
eureka.instance.hostname=${eureka.hostname}
eureka.client.serviceUrl.defaultZone=http://${eureka.hostname}:${eureka.port}/eureka/

eureka.client.healthcheck.enabled=${eureka.healthcheck}
eureka.instance.lease-renewal-interval-in-seconds=${eureka.lease-renewal-interval-in-seconds}
eureka.instance.lease-expiration-duration-in-seconds=${eureka.lease-expiration-duration-in-seconds}
eureka.instance.prefer-ip-address=${eureka.prefer-ip-address}
eureka.instance.instance-id=${eureka.instance-id}

app.access.cross-domain=${cross-domain}

temp.path.win=${windows.temp}/bug
temp.path.linux=${linux.temp}/bug

spring.rabbitmq.host=${rabbitmq.host}
spring.rabbitmq.port=${rabbitmq.port}
spring.rabbitmq.username=${rabbitmq.username}
spring.rabbitmq.password=${rabbitmq.password}
spring.rabbitmq.virtualHost=${rabbitmq.virtualHost}

#feign request add cookie
hystrix.command.default.execution.isolation.strategy=${hystrix.isolation.strategy}
#feign request time-out
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=${hystrix.timeoutInMilliseconds}

#检查用户权限,0=不检查登录，1=不检查权限，2=检查权限
auth.check=1

mapper.mappers=cn.lz.bug.util.BaseMapper
mapper.not-empty=false
mapper.identity=MYSQL